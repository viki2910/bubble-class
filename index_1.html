<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ë²„ë¸”ë²„ë¸” ìŠˆí„°</title>
  <style>
    :root{--bg:#0b1024;--panel:#111827;--text:#e5e7eb;--accent:#38bdf8}
    html,body{height:100%;margin:0}
    body{display:grid;place-items:center;background:radial-gradient(1200px 800px at 70% -20%, #1f2937, #0b1024 60%, #050816 100%);font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,sans-serif;color:var(--text)}
    .wrap{width:min(800px,96vw)}
    .hud{display:grid;grid-template-columns:1fr auto;gap:.5rem;align-items:center;background:rgba(17,24,39,.65);backdrop-filter:blur(4px);border:1px solid #263146;border-bottom:none;border-radius:16px 16px 0 0;padding:.5rem 1rem}
    .title{font-weight:700;letter-spacing:.3px}
    .btns{display:flex;gap:.5rem}
    button{all:unset;background:#0f172a;border:1px solid #273247;padding:.35rem .7rem;border-radius:10px;cursor:pointer}
    button:hover{background:#14213a}
    canvas{display:block;background:linear-gradient(#0a1227,#071022);border:1px solid #263146;border-radius:0 0 16px 16px}
    .tips{font-size:.9rem;opacity:.9;margin-top:.5rem;text-align:center}
    a{color:#a0e7ff}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="title">ğŸ¯ ë²„ë¸”ë²„ë¸” ìŠˆí„° â€” ê°™ì€ ìƒ‰ 3ê°œ ì´ìƒ ë§ì¶”ë©´ ì œê±°!</div>
      <div class="btns">
        <button id="btnRestart">ì¬ì‹œì‘</button>
        <button id="btnAddRow" title="ë‚œì´ë„ ì—…! ìœ„ì—ì„œ í•œ ì¤„ ì¶”ê°€">í•œ ì¤„ ì¶”ê°€</button>
      </div>
    </div>
    <canvas id="game" width="800" height="1000" aria-label="ë²„ë¸”ë²„ë¸” ê²Œì„ ìº”ë²„ìŠ¤"></canvas>
    <div class="tips">ë§ˆìš°ìŠ¤(ë˜ëŠ” í„°ì¹˜)ë¡œ ì¡°ì¤€í•˜ê³  í´ë¦­í•˜ë©´ ë°œì‚¬í•©ë‹ˆë‹¤. Space: ë°œì‚¬ / A,D: ì¢Œìš° íšŒì „ / R: ì¬ì‹œì‘</div>
  </div>

  <script>
  // =========================
  // Bubble Shooter (Hex Grid)
  // =========================
  (()=>{
    const cvs = document.getElementById('game');
    const ctx = cvs.getContext('2d');

    // --- Layout & Constants ---
    const W = cvs.width;
    const H = cvs.height;

    const TOP_MARGIN = 70;        // ìƒë‹¨ ì—¬ë°± (UIìš©)
    const LAUNCH_Y = H - 110;     // ë°œì‚¬ëŒ€ Y
    const R = 18;                 // ë²„ë¸” ë°˜ì§€ë¦„
    const DIAM = R*2;
    const COLS = 16;              // ì§ìˆ˜í–‰ ê¸°ì¤€ ì—´ ìˆ˜
    const ROW_H = Math.sqrt(3) * R; // ìœ¡ê° í˜•íƒœì˜ ìˆ˜ì§ ê°„ê²©
    const COLORS = ['#ff6b6b','#ffd93d','#6bcB77','#4d96ff','#bb86fc','#ff9f1c'];

    const MAX_ROWS_VISIBLE = Math.floor((H - TOP_MARGIN - 200) / ROW_H) + 2;

    // ê²Œì„ ìƒíƒœ
    const state = {
      grid: [],          // 2D grid: { color, row, col, x, y }
      offsetRow: 0,      // ë§¨ ìœ„ê°€ ì§ìˆ˜í–‰ì¸ì§€ ì—¬ë¶€ (0=ì§,1=í™€)
      aimAngle: -Math.PI/2,
      current: null,     // ë‚ ì•„ê°€ëŠ” ë²„ë¸”
      nextColor: rndColor(),
      score: 0,
      shots: 0,
      gameOver: false,
      level: 1,
    };

    function rndColor(){ return COLORS[(Math.random()*COLORS.length)|0]; }

    // --- Grid Helpers ---
    function colCountForRow(row){
      return COLS - ( ( (row + state.offsetRow) & 1 ) ? 1 : 0 );
    }
    function xForCell(row,col){
      const odd = ((row + state.offsetRow) & 1);
      const base = odd ? R + R : R; // í™€ìˆ˜í–‰ì€ ë°˜ì¹¸ ì˜¤ë¥¸ìª½ìœ¼ë¡œ
      return base + col*DIAM + (odd?R:0) + 20; // ì¢Œì¸¡ ì—¬ë°± 20
    }
    function yForRow(row){ return TOP_MARGIN + row*ROW_H; }

    function addRow(colors=null){
      const row = [];
      const cols = colCountForRow(0);
      for(let c=0;c<cols;c++){
        row.push({color: colors? colors[c]: rndColor(), row:0, col:c});
      }
      // ê¸°ì¡´ í–‰ë“¤ì˜ rowë¥¼ +1ì”© ë°€ê¸°
      for(const r of state.grid){ for(const b of r){ b.row++; } }
      state.grid.unshift(row);
      // ë„ˆë¬´ ì•„ë˜ë¡œ ë‚´ë ¤ì˜¤ë©´ ê²Œì„ì˜¤ë²„
      for(const b of state.grid[state.grid.length-1]||[]){
        if(yForRow(b.row) + R*1.2 >= LAUNCH_Y){ state.gameOver = true; }
      }
    }

    function initGrid(rows=6){
      state.grid = [];
      state.offsetRow = 0;
      for(let r=0;r<rows;r++) addRow();
    }

    function layoutGrid(){
      for(let r=0;r<state.grid.length;r++){
        const row = state.grid[r];
        for(let c=0;c<row.length;c++){
          const b = row[c];
          b.x = xForCell(b.row,b.col);
          b.y = yForRow(b.row);
        }
      }
    }

    function neighbors(cell){
      // ìœ¡ê° ê·¸ë¦¬ë“œ ì¸ì ‘ ì¢Œí‘œ (í–‰ offsetì— ë”°ë¼ ì¢Œìš° ë‹¤ë¦„)
      const {row, col} = cell;
      const odd = ((row + state.offsetRow) & 1);
      const deltas = odd ? [
        [0,-1],[0,1],[-1,0],[-1,1],[1,0],[1,1]
      ]:[
        [0,-1],[0,1],[-1,-1],[-1,0],[1,-1],[1,0]
      ];
      const res=[];
      for(const [dr,dc] of deltas){
        const rr=row+dr, cc=col+dc;
        const rRow = state.grid.find(r=> r.length && r[0].row===rr);
        if(!rRow) continue;
        const n = rRow.find(b=> b.col===cc);
        if(n) res.push(n);
      }
      return res;
    }

    function findCluster(start, matchColor=true){
      const targetColor = start.color;
      const visited=new Set();
      const q=[start];
      visited.add(start);
      while(q.length){
        const cur=q.shift();
        for(const n of neighbors(cur)){
          if(visited.has(n)) continue;
          if(!matchColor || n.color===targetColor){ visited.add(n); q.push(n);}        
        }
      }
      return [...visited];
    }

    function removeBubbles(list){
      if(!list.length) return;
      const mark = new Set(list);
      for(const row of state.grid){
        for(let i=row.length-1;i>=0;i--){ if(mark.has(row[i])) row.splice(i,1); }
      }
      // ë¹ˆ í–‰ ì œê±°
      for(let i=state.grid.length-1;i>=0;i--){ if(state.grid[i].length===0) state.grid.splice(i,1); }
    }

    function dropFloating(){
      // ìœ„ìª½ í…Œë‘ë¦¬ì— ë‹¿ì•„ìˆëŠ” ë²„ë¸”ë¡œë¶€í„° ì—°ê²°ë˜ì§€ ì•Šì€ ë²„ë¸”ë“¤ì€ ë–¨ì–´ì§
      const anchored = new Set();
      const topRows = state.grid.filter(r=> r.length && r[0].row===0);
      for(const r of topRows){
        for(const b of r){ for(const v of findCluster(b,false)) anchored.add(v); }
      }
      const floating=[];
      for(const row of state.grid){
        for(const b of row){ if(!anchored.has(b)) floating.push(b); }
      }
      removeBubbles(floating);
      return floating.length;
    }

    // --- Shooting Mechanics ---
    function newBullet(){
      state.current = {
        x: W/2,
        y: LAUNCH_Y,
        vx: Math.cos(state.aimAngle)*7.5,
        vy: Math.sin(state.aimAngle)*7.5,
        color: state.nextColor,
        flying: true
      };
      state.nextColor = rndColor();
      state.shots++;
    }

    function canFire(){ return !state.gameOver && (!state.current || !state.current.flying); }

    function reflectIfNeeded(b){
      if(b.x <= R+20 && b.vx<0){ b.vx*=-1; b.x = R+20; }
      if(b.x >= W-R-20 && b.vx>0){ b.vx*=-1; b.x = W-R-20; }
    }

    function collideOrTop(b){
      if(b.y <= TOP_MARGIN + R){ return true; }
      // ê¸°ì¡´ ë²„ë¸”ê³¼ì˜ ì¶©ëŒ ì²´í¬
      for(const row of state.grid){
        for(const p of row){
          const dx=b.x-p.x, dy=b.y-p.y; if(dx*dx+dy*dy <= DIAM*DIAM-0.1){ return p; }
        }
      }
      return false;
    }

    function snapToGrid(b, target){
      // target ì£¼ìœ„ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ë¹ˆ ì…€ ì°¾ê¸°
      const candidates = [];
      for(const n of [target, ...neighbors(target)]){
        const odd = ((n.row + state.offsetRow) & 1);
        const spots = odd ? [ [0,-1],[0,1],[-1,0],[-1,1],[1,0],[1,1] ] : [ [0,-1],[0,1],[-1,-1],[-1,0],[1,-1],[1,0] ];
        for(const [dr,dc] of spots){
          const rr=n.row+dr, cc=n.col+dc;
          if(rr<0||cc<0) continue;
          const existRow = state.grid.find(r=> r.length && r[0].row===rr);
          let occupied=false;
          if(existRow){ occupied = !!existRow.find(x=> x.col===cc); }
          const cols = colCountForRow(rr);
          if(cc>=cols) continue;
          if(!occupied){
            const x = xForCell(rr,cc), y=yForRow(rr);
            const dist2=(b.x-x)*(b.x-x)+(b.y-y)*(b.y-y);
            candidates.push({rr,cc,x,y,dist2});
          }
        }
      }
      if(!candidates.length){ // ë¹„ì •ìƒ ì¼€ì´ìŠ¤: ê·¸ëƒ¥ ìœ„ì— ë¶™ì´ê¸°
        const rr = Math.max(0, Math.round((b.y-TOP_MARGIN)/ROW_H));
        const cc = Math.round((b.x-20 - ( ((rr+state.offsetRow)&1)? DIAM: R*2 ))/DIAM);
        return {row:rr,col:Math.max(0,cc)};
      }
      candidates.sort((a,b2)=>a.dist2-b2.dist2);
      return {row:candidates[0].rr, col:candidates[0].cc};
    }

    function placeAndResolve(cell, color){
      // í•´ë‹¹ rowê°€ ì—†ìœ¼ë©´ ìƒì„±
      let rowRef = state.grid.find(r=> r.length && r[0].row===cell.row);
      if(!rowRef){
        // í•„ìš”í•œ ê²½ìš° ì¤‘ê°„ ë¹ˆ í–‰ë“¤ë„ ë§Œë“¤ì–´ ì¤€ë‹¤
        const maxRow = state.grid.length? Math.max(...state.grid.map(r=>r[0].row)) : -1;
        for(let r=maxRow+1;r<=cell.row;r++) state.grid.push([]);
        rowRef = state.grid.find(r=> r.length===0) || [];
        // ìœ„ ë£¨í”„ í›„ rowRefê°€ ë¹„ì—ˆì„ ìˆ˜ ìˆìœ¼ë‹ˆ ê°•ì œë¡œ ë§ì¶° ë„£ê¸°
        rowRef.rowIndex = cell.row;
        // gridì˜ ê° ë¹ˆ ë°°ì—´ì— row í‘œì‹œìš© dummyë¥¼ ë„£ì -> ëŒ€ì‹  ì•„ë˜ pushì—ì„œ row, colì„ ì„¸íŒ…
      }
      // í•´ë‹¹ rowì˜ ì‹¤ì œ ì°¸ì¡°ë¥¼ ë‹¤ì‹œ êµ¬í•¨ (row ê°’ì´ ë§ëŠ” ë°°ì—´)
      rowRef = state.grid.find(r=> r.length && r[0].row===cell.row) || (()=>{
        const arr=[]; arr.push({color:'#00000000',row:cell.row,col:-999,ghost:true});
        state.grid.push(arr);
        return arr;
      })();
      // ghost ì •ë¦¬
      for(let i=rowRef.length-1;i>=0;i--){ if(rowRef[i].ghost) rowRef.splice(i,1); }

      const bubble = { color, row:cell.row, col:cell.col };
      rowRef.push(bubble);

      // ì¢Œí‘œ ì¬ê³„ì‚°
      layoutGrid();

      // ë§¤ì¹˜ íŒì •
      const cluster = findCluster(bubble,true);
      let removed = 0;
      if(cluster.length >= 3){ removeBubbles(cluster); removed += cluster.length; }
      removed += dropFloating();

      if(removed>0){ state.score += removed*10; }

      // ë‚œì´ë„: ì¼ì • ë°œì‚¬ ìˆ˜ë§ˆë‹¤ í–‰ ì¶”ê°€
      if(state.shots>0 && state.shots%6===0){ state.level++; addRow(); layoutGrid(); }

      // ìŠ¹ë¦¬ ì¡°ê±´: ëª¨ë“  ë²„ë¸” ì œê±°
      const any = state.grid.some(r=> r.length);
      if(!any){
        state.gameOver = true;
        toast('ğŸ‰ í´ë¦¬ì–´! ì ìˆ˜: '+state.score);
      }
    }

    // --- Input ---
    let mouseX=W/2, mouseY=LAUNCH_Y-200;
    cvs.addEventListener('mousemove', e=>{
      const rect = cvs.getBoundingClientRect();
      mouseX = (e.clientX-rect.left) * (cvs.width/rect.width);
      mouseY = (e.clientY-rect.top) * (cvs.height/rect.height);
      state.aimAngle = Math.atan2(mouseY-LAUNCH_Y, mouseX-W/2);
      clampAim();
    });
    cvs.addEventListener('touchmove', e=>{
      const t = e.touches[0]; if(!t) return;
      const rect = cvs.getBoundingClientRect();
      mouseX = (t.clientX-rect.left) * (cvs.width/rect.width);
      mouseY = (t.clientY-rect.top) * (cvs.height/rect.height);
      state.aimAngle = Math.atan2(mouseY-LAUNCH_Y, mouseX-W/2);
      clampAim();
      e.preventDefault();
    }, {passive:false});

    function clampAim(){
      const min = -Math.PI + 0.15; // ì¢Œì¸¡ 171ë„
      const max = -0.15;           // ìš°ì¸¡ 9ë„
      if(state.aimAngle<min) state.aimAngle=min;
      if(state.aimAngle>max) state.aimAngle=max;
    }

    function fire(){ if(canFire()) newBullet(); }

    cvs.addEventListener('click', fire);
    cvs.addEventListener('touchend', e=>{ fire(); e.preventDefault(); }, {passive:false});

    window.addEventListener('keydown', e=>{
      if(e.code==='Space'){ e.preventDefault(); fire(); }
      if(e.key==='a' || e.key==='A'){ state.aimAngle -= 0.07; clampAim(); }
      if(e.key==='d' || e.key==='D'){ state.aimAngle += 0.07; clampAim(); }
      if(e.key==='r' || e.key==='R'){ restart(); }
    });

    document.getElementById('btnRestart').onclick=()=>restart();
    document.getElementById('btnAddRow').onclick=()=>{ addRow(); layoutGrid(); };

    // --- Rendering ---
    function drawBubble(x,y,color,stroke=true){
      ctx.beginPath(); ctx.arc(x,y,R,0,Math.PI*2);
      const g = ctx.createRadialGradient(x-R*0.4, y-R*0.4, R*0.3, x, y, R);
      g.addColorStop(0,'#ffffff'); g.addColorStop(0.15,'#ffffff'); g.addColorStop(0.16,color);
      g.addColorStop(1,color);
      ctx.fillStyle=g; ctx.fill();
      if(stroke){ ctx.lineWidth=2; ctx.strokeStyle='rgba(0,0,0,.35)'; ctx.stroke(); }
    }

    function draw(){
      ctx.clearRect(0,0,W,H);
      // Top bar
      ctx.fillStyle='rgba(0,0,0,.25)'; ctx.fillRect(0,0,W,TOP_MARGIN-4);
      ctx.fillStyle='#cde7ff'; ctx.font='bold 18px system-ui,Segoe UI,Roboto';
      ctx.fillText(`ì ìˆ˜: ${state.score}  |  ë ˆë²¨: ${state.level}  |  ë°œì‚¬ìˆ˜: ${state.shots}`, 16, 28);
      if(state.gameOver){
        ctx.fillStyle='#ffdde1'; ctx.fillText('ê²Œì„ì´ ëë‚¬ìŠµë‹ˆë‹¤. R: ì¬ì‹œì‘', 16, 52);
      } else {
        ctx.fillStyle='#a8ffec'; ctx.fillText('3ê°œ ì´ìƒ ë¶™ì´ë©´ ì œê±°ë©ë‹ˆë‹¤. ë– ìˆëŠ” ë²„ë¸”ì€ ë‚™í•˜!', 16, 52);
      }

      // Grid
      for(const row of state.grid){
        for(const b of row){ if(b.ghost) continue; drawBubble(b.x,b.y,b.color); }
      }

      // Launcher base
      ctx.save();
      ctx.translate(W/2, LAUNCH_Y);
      // cannon
      ctx.rotate(state.aimAngle);
      ctx.fillStyle='#1e293b'; ctx.strokeStyle='#0ea5e9'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.roundRect(-14,-14,90,28,14); ctx.fill(); ctx.stroke();
      ctx.restore();

      // current bullet
      if(state.current){ drawBubble(state.current.x, state.current.y, state.current.color); }

      // next preview
      ctx.globalAlpha=.9;
      ctx.fillStyle='#9ca3af'; ctx.fillText('ë‹¤ìŒ:', W-150, 32);
      drawBubble(W-80, 28, state.nextColor, false);
      ctx.globalAlpha=1;
    }

    // --- Game Loop ---
    let last=0;
    function step(ts){
      const dt = (ts-last)/16.6667; last=ts;
      update(dt);
      draw();
      requestAnimationFrame(step);
    }

    function update(dt){
      if(state.gameOver) return;
      if(state.current && state.current.flying){
        const b = state.current;
        b.x += b.vx*dt; b.y += b.vy*dt;
        reflectIfNeeded(b);
        const hit = collideOrTop(b);
        if(hit){
          // ì¶©ëŒ ì²˜ë¦¬
          b.flying=false;
          const targetCell = hit===true ? {row:0,col: Math.max(0, Math.min(colCountForRow(0)-1, Math.round((b.x - ( ((state.offsetRow)&1)? R*2+20 : R+20 ))/DIAM)))} : snapToGrid(b, hit);
          placeAndResolve(targetCell, b.color);
          state.current=null;
        }
      }
    }

    // --- Utils ---
    function toast(text){
      // ê°„ë‹¨ í† ìŠ¤íŠ¸
      const el = document.createElement('div');
      el.textContent = text;
      el.style.cssText = 'position:fixed;left:50%;top:18px;transform:translateX(-50%);background:#0b1328;color:#dff7ff;border:1px solid #274966;padding:.4rem .7rem;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,.35);z-index:9999;opacity:0;transition:opacity .2s ease';
      document.body.appendChild(el);
      requestAnimationFrame(()=>{ el.style.opacity=1; });
      setTimeout(()=>{ el.style.opacity=0; setTimeout(()=>el.remove(),200); }, 1600);
    }

    function restart(){
      state.grid=[]; state.score=0; state.shots=0; state.level=1; state.gameOver=false; state.nextColor=rndColor(); state.current=null;
      initGrid(6); layoutGrid(); toast('ğŸ”„ ì¬ì‹œì‘');
    }

    // --- Start ---
    initGrid(6); layoutGrid();
    requestAnimationFrame(step);
  })();
  </script>
</body>
</html>
