<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ë²„ë¸”ë²„ë¸” - Bubble Shooter</title>
  <style>
    :root {
      --bg:#0b1020; --panel:#111827; --text:#e5e7eb; --accent:#60a5fa; --good:#34d399; --bad:#f43f5e;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,sans-serif;
      background: radial-gradient(1200px 800px at 70% -20%, #1f2937, #0b1024 60%, #050816 100%);
      color: var(--text); display:grid; place-items:center; overflow: hidden;
    }
    .wrap { width:min(520px, 94vw); }
    .hud { display:grid; grid-template-columns:1fr auto; gap:.5rem; align-items:center;
      background:rgba(17,24,39,.6); backdrop-filter: blur(6px); padding:.75rem 1rem; border-radius: 1rem; box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    .hud h1 { margin:0; font-size:1.1rem; letter-spacing:.3px; font-weight:700; }
    .hud .right { display:flex; gap:.5rem; align-items:center; }
    .pill { padding:.35rem .6rem; border-radius: 999px; font-weight:700; font-size:.85rem; background:#0b1226; border:1px solid #1f2b4f; }
    .btn { cursor:pointer; user-select:none; padding:.45rem .8rem; border-radius: 999px; border:1px solid #2a375f; background: linear-gradient(180deg,#14204a,#0c1430); font-weight:700; }
    .btn:hover { filter: brightness(1.1); }
    .canvas-wrap { position: relative; margin-top:.75rem; border-radius: 1rem; overflow: hidden; box-shadow: 0 20px 40px rgba(0,0,0,.45); border:1px solid #1b2350; }
    canvas { display:block; width:100%; height:auto; background: linear-gradient(180deg,#0a0f22,#0c1a39 40%, #0b1020); }
    .help { opacity:.9; font-size:.9rem; text-align:center; margin-top:.5rem; }
    .toast { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
      background:rgba(15,23,42,.85); padding:1rem 1.25rem; border-radius:1rem; border:1px solid #334155; text-align:center;
      box-shadow: 0 10px 30px rgba(0,0,0,.45); display:none; }
    .toast h2 { margin:.1rem 0 .4rem; font-size:1.25rem; }
    .toast .row { display:flex; gap:.5rem; justify-content:center; margin-top:.25rem; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <h1>ë²„ë¸”ë²„ë¸” Â· Bubble Shooter</h1>
      <div class="right">
        <span class="pill" id="score">ì ìˆ˜ 0</span>
        <span class="pill" id="rows">ë‚¨ì€ì¤„ 0</span>
        <button class="btn" id="restart">ë‹¤ì‹œ ì‹œì‘</button>
      </div>
    </div>

    <div class="canvas-wrap">
      <canvas id="game" width="480" height="720" aria-label="ë²„ë¸”ë²„ë¸” ê²Œì„ ìº”ë²„ìŠ¤"></canvas>
      <div class="toast" id="toast">
        <h2 id="toast-title">ê²Œì„ ì˜¤ë²„</h2>
        <div id="toast-msg">ì ìˆ˜ë¥¼ í™•ì¸í•˜ê³  ë‹¤ì‹œ ë„ì „í•˜ì„¸ìš”!</div>
        <div class="row"><button class="btn" id="toast-restart">ë‹¤ì‹œ ì‹œì‘</button></div>
      </div>
    </div>
    <div class="help">ë§ˆìš°ìŠ¤(ë˜ëŠ” ì†ê°€ë½)ë¡œ ì¡°ì¤€í•˜ê³  í´ë¦­/íƒ­í•˜ì—¬ ë°œì‚¬! Â· ê°™ì€ ìƒ‰ 3ê°œ ì´ìƒ ì—°ê²°í•˜ë©´ í„°ì§‘ë‹ˆë‹¤ ğŸ’¥</div>
  </div>

<script>
// === ë²„ë¸”ë²„ë¸”: ìˆœìˆ˜ JS + Canvas (1íŒŒì¼ ì™„ì„±) ===============================
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const rowsEl = document.getElementById('rows');
  const restartBtn = document.getElementById('restart');
  const toast = document.getElementById('toast');
  const toastTitle = document.getElementById('toast-title');
  const toastMsg = document.getElementById('toast-msg');
  const toastRestart = document.getElementById('toast-restart');

  // ìº”ë²„ìŠ¤ í¬ê¸° ê³ ì •(ë¹„ìœ¨ ìœ ì§€) + CSSë¡œ ë°˜ì‘í˜•. ë‚´ë¶€ ì¢Œí‘œëŠ” ê³ ì •.
  const W = canvas.width; const H = canvas.height;

  // ê²©ì ì„¤ì •(ë²Œì§‘í˜• ê°€ê¹Œìš´ ìŠ¤íƒœê±°ë“œ)
  const R = 16;                 // ë²„ë¸” ë°˜ì§€ë¦„
  const COLS = 12;              // ê¸°ë³¸ ì—´ ìˆ˜
  const ROW_H = Math.floor(R * 1.75); // ì¤„ ê°„ê²© (ëŒ€ëµ âˆš3 * R)
  const START_ROWS = 6;         // ì‹œì‘ ì¤„ ìˆ˜
  const CEIL_PAD = 50;          // ì²œì¥ ì—¬ìœ 
  const SHOOT_Y = H - 60;       // ë°œì‚¬ ìœ„ì¹˜ Y
  const MAX_ROWS = Math.floor((H - CEIL_PAD - 120) / ROW_H);

  const COLORS = ['#60a5fa','#f472b6','#fbbf24','#34d399','#a78bfa','#f97316','#22d3ee'];

  // ìƒíƒœ
  let grid = [];      // 2D ë°°ì—´(í–‰ -> ì—´)
  let score = 0;
  let shots = 0;
  let pendingRows = 5; // ì¼ì • ë°œì‚¬ë§ˆë‹¤ ì¤„ ë‚´ë ¤ì˜´(ì¹´ìš´íŠ¸ë‹¤ìš´)
  let gameOver = false;

  // ë°œì‚¬ì²´
  let current = null; // {x,y,vx,vy,color}
  let nextColor = COLORS[Math.floor(Math.random()*COLORS.length)];

  // ìœ í‹¸
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  function newGrid(rows=START_ROWS){
    grid = [];
    for(let r=0;r<rows;r++){
      const odd = r % 2 === 1;
      const cols = odd ? COLS-1 : COLS;
      const row = new Array(cols).fill(null);
      // ì„ì˜ë¡œ ìƒ‰ ì±„ìš°ê¸°(ì—°ê²° ê°€ëŠ¥ì„± ë†’ì´ê¸°)
      for(let c=0;c<cols;c++){
        row[c] = { color: COLORS[Math.floor(Math.random()*COLORS.length)] };
      }
      grid.push(row);
    }
  }

  function gridToXY(r,c){
    const odd = r % 2 === 1;
    const x0 = odd ? R*2 : R;
    const x = x0 + c * (R*2);
    const y = CEIL_PAD + r * ROW_H;
    return {x,y};
  }

  function xyToGrid(x,y){
    // ëŒ€ëµì ì¸ ë°˜ì „ ë§¤í•‘: í›„ë³´ ê²©ì 4~6ê°œ ì¤‘ ê°€ì¥ ê°€ê¹Œìš´ ìœ„ì¹˜ë¡œ ìŠ¤ëƒ…
    const rApprox = Math.round((y - CEIL_PAD)/ROW_H);
    const candidates = [];
    for(let dr=-1;dr<=1;dr++){
      const r = rApprox + dr;
      if(r<0) continue;
      const odd = r%2===1;
      const cols = odd? COLS-1: COLS;
      // col ê·¼ì‚¬: (x - x0) / (2R)
      const x0 = odd? R*2 : R;
      const cApprox = Math.round((x - x0)/(R*2));
      for(let dc=-1;dc<=1;dc++){
        const c = cApprox + dc;
        if(c<0||c>=cols) continue;
        const p = gridToXY(r,c);
        const d2 = (p.x - x)**2 + (p.y - y)**2;
        candidates.push({r,c,d2});
      }
    }
    if(candidates.length===0) return null;
    candidates.sort((a,b)=>a.d2-b.d2);
    return {r:candidates[0].r, c:candidates[0].c};
  }

  function neighbors(r,c){
    const odd = r%2===1;
    // ìŠ¤íƒœê±°ë“œ 6ë°©í–¥ ê·¼ì‚¬
    const n = odd
      ? [[r-1,c],[r-1,c+1],[r,c-1],[r,c+1],[r+1,c],[r+1,c+1]]
      : [[r-1,c-1],[r-1,c],[r,c-1],[r,c+1],[r+1,c-1],[r+1,c]];
    return n.filter(([rr,cc])=> rr>=0 && rr<grid.length && cc>=0 && cc<grid[rr].length);
  }

  function floodSame(r,c,color,visited){
    const key = r+","+c;
    if(visited.has(key)) return;
    visited.add(key);
    for(const [rr,cc] of neighbors(r,c)){
      const cell = grid[rr]?.[cc];
      if(cell && cell.color===color) floodSame(rr,cc,color,visited);
    }
  }

  function removeFloating(){
    // ì²œì¥(0í–‰)ê³¼ ì—°ê²°ë˜ì§€ ì•Šì€ ë²„ë¸” ì œê±°
    const seen = new Set();
    for(let c=0;c<grid[0]?.length;c++){
      if(grid[0][c]) floodAttach(0,c,seen);
    }
    let removed = 0;
    for(let r=0;r<grid.length;r++){
      for(let c=0;c<grid[r].length;c++){
        const key = r+","+c;
        if(grid[r][c] && !seen.has(key)) { grid[r][c]=null; removed++; }
      }
    }
    return removed;
  }
  function floodAttach(r,c,seen){
    const key = r+","+c; if(seen.has(key)) return; seen.add(key);
    for(const [rr,cc] of neighbors(r,c)){
      const cell = grid[rr]?.[cc];
      if(cell) floodAttach(rr,cc,seen);
    }
  }

  function compressGrid(){
    // ë§¨ ì•„ë˜ ë¹„ì–´ìˆëŠ” í–‰ ì œê±°, ìœ„ë¡œë§Œ ì¡´ì¬
    for(let r=grid.length-1;r>=0;r--){
      if(grid[r].every(v=>v==null)) grid.splice(r,1);
      else break;
    }
  }

  function spawnProjectile(){
    const color = nextColor;
    nextColor = COLORS[Math.floor(Math.random()*COLORS.length)];
    current = { x: W/2, y: SHOOT_Y, vx:0, vy:0, color };
  }

  function beginShot(angle){
    const speed = 7.2;
    current.vx = Math.cos(angle)*speed;
    current.vy = Math.sin(angle)*speed;
  }

  function tryAttach(){
    const snap = xyToGrid(current.x, current.y);
    if(!snap) return false;
    const {r,c} = snap;
    // ê·¸ë¦¬ë“œ í™•ì¥ í•„ìš” ì‹œ
    while(r >= grid.length){
      const odd = grid.length % 2 === 1;
      const cols = odd? COLS-1: COLS;
      grid.push(new Array(cols).fill(null));
    }
    if(grid[r][c]) return false; // ì´ë¯¸ ì°¬ ìë¦¬ë©´ ì‹¤íŒ¨(ì¡°ê¸ˆ ë” ì§„í–‰)
    grid[r][c] = { color: current.color };

    // ê·¸ë£¹ ê²€ì‚¬(3ê°œ ì´ìƒ)
    const visited = new Set();
    floodSame(r,c,current.color,visited);
    let removed = 0;
    if(visited.size >= 3){
      for(const k of visited){
        const [rr,cc] = k.split(',').map(Number);
        grid[rr][cc] = null; removed++;
      }
      score += removed * 10;
    }
    // ê³µì¤‘ë¶€ì–‘ ì œê±°
    const floating = removeFloating();
    if(floating>0) score += floating * 15;

    compressGrid();
    updateUI();

    // ê²Œì„ í´ë¦¬ì–´ ì²´í¬
    if(grid.length===0){
      endGame(true);
    }
    return true;
  }

  function lowerRows(n=1){
    // ì•„ë˜ë¡œ í•œ ì¤„ ì¶”ê°€: ì²œì¥ì— ìƒˆ ì¤„ ì‚½ì… íš¨ê³¼
    for(let i=0;i<n;i++){
      const newTopOdd = 0 % 2 === 1; // ì²«ì¤„ì€ í•­ìƒ ì§ìˆ˜í–‰(odd=false)
      const cols = newTopOdd ? COLS-1 : COLS;
      const row = new Array(cols).fill(null).map(()=>({color: COLORS[Math.floor(Math.random()*COLORS.length)]}));
      grid.unshift(row);
    }
    // ë°”ë‹¥ ë‹¿ì•˜ëŠ”ì§€ ì²´í¬
    const lowestY = CEIL_PAD + (grid.length-1)*ROW_H + R;
    if(lowestY >= SHOOT_Y - R){
      endGame(false);
    }
  }

  function aimAngle(mx,my){
    const dx = mx - W/2; const dy = my - SHOOT_Y;
    let ang = Math.atan2(dy,dx);
    // ìœ„ìª½ë§Œ í—ˆìš©(ë°œì‚¬ê° ì œí•œ)
    const minA = (-Math.PI + 0.2), maxA = (-0.2);
    ang = clamp(ang, minA, maxA);
    return ang;
  }

  // ì…ë ¥ ì²˜ë¦¬
  let mouse = {x:W/2, y:SHOOT_Y-100};
  function onPoint(x,y){ mouse.x=x; mouse.y=y; }
  canvas.addEventListener('mousemove', e=>{
    const rect = canvas.getBoundingClientRect();
    const scale = rect.width / W;
    onPoint((e.clientX-rect.left)/scale, (e.clientY-rect.top)/scale);
  });
  canvas.addEventListener('touchmove', e=>{
    const t = e.touches[0]; if(!t) return; const rect = canvas.getBoundingClientRect();
    const scale = rect.width / W;
    onPoint((t.clientX-rect.left)/scale, (t.clientY-rect.top)/scale);
  }, {passive:true});

  function shoot(){
    if(gameOver) return;
    if(!current) spawnProjectile();
    if(current.vx!==0||current.vy!==0) return; // ì´ë¯¸ ë°œì‚¬ì¤‘
    const ang = aimAngle(mouse.x, mouse.y);
    beginShot(ang);
    shots++;
    pendingRows--;
    if(pendingRows<=0){
      pendingRows = 5; // 5ë°œ ë§ˆë‹¤ í•œ ì¤„ ë‚´ë ¤ì˜¤ê¸°
      lowerRows(1);
      updateUI();
    }
  }
  canvas.addEventListener('click', shoot);
  canvas.addEventListener('touchstart', e=>{ shoot(); }, {passive:true});

  restartBtn.addEventListener('click', resetGame);
  toastRestart.addEventListener('click', resetGame);

  function updateUI(){
    scoreEl.textContent = `ì ìˆ˜ ${score}`;
    rowsEl.textContent = `ë‚¨ì€ì¤„ ${pendingRows}`;
  }

  function endGame(clear){
    gameOver = true;
    toast.style.display = 'block';
    toastTitle.textContent = clear? 'í´ë¦¬ì–´! ğŸ‰' : 'ê²Œì„ ì˜¤ë²„ ğŸ’€';
    toastMsg.textContent = `ìµœì¢… ì ìˆ˜: ${score} Â· ë°œì‚¬ìˆ˜: ${shots}`;
  }

  function resetGame(){
    toast.style.display = 'none';
    score = 0; shots = 0; pendingRows = 5; gameOver = false;
    newGrid(START_ROWS);
    current = null; nextColor = COLORS[Math.floor(Math.random()*COLORS.length)];
    updateUI();
  }

  function step(){
    // ë¬¼ë¦¬ ì—…ë°ì´íŠ¸
    if(current){
      if(current.vx!==0 || current.vy!==0){
        current.x += current.vx; current.y += current.vy;
        // ë²½ ë°˜ì‚¬
        if(current.x <= R){ current.x = R; current.vx *= -1; }
        if(current.x >= W - R){ current.x = W - R; current.vx *= -1; }
        // ì²œì¥ ì¶©ëŒ
        if(current.y <= CEIL_PAD + R){ current.y = CEIL_PAD + R; if(tryAttach()) current = null; }
        else {
          // ë‹¤ë¥¸ ë²„ë¸”ê³¼ ì¶©ëŒ ì²´í¬(ì›-ì›)
          outer: for(let r=0;r<grid.length;r++){
            for(let c=0;c<grid[r].length;c++){
              const cell = grid[r][c]; if(!cell) continue;
              const p = gridToXY(r,c);
              const dx = p.x - current.x; const dy = p.y - current.y;
              const dist = Math.hypot(dx,dy);
              if(dist <= R*2 - 0.5){ // ì•½ê°„ ê²¹ì¹˜ë©´ ìŠ¤ëƒ…
                // ì¶©ëŒ ì§€ì ì—ì„œ ì‚´ì§ ë’¤ë¡œ ì´ë™(ê²¹ì¹¨ ì¤„ì´ê¸°)
                const nx = dx/dist, ny = dy/dist;
                current.x = p.x - nx*(R*2);
                current.y = p.y - ny*(R*2);
                if(tryAttach()) current = null;
                break outer;
              }
            }
          }
          // ë°”ë‹¥ì— ë‹¿ìœ¼ë©´ ì‹¤íŒ¨
          if(current && current.y >= SHOOT_Y - R){ endGame(false); current=null; }
        }
      }
    }
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    // ë°°ê²½(ê°€ì´ë“œ)
    const grd = ctx.createLinearGradient(0,0,0,H);
    grd.addColorStop(0,'#0a0f22'); grd.addColorStop(.5,'#0c1a39'); grd.addColorStop(1,'#0b1020');
    ctx.fillStyle = grd; ctx.fillRect(0,0,W,H);

    // ì²œì¥ ë¼ì¸
    ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 2; ctx.beginPath();
    ctx.moveTo(0, CEIL_PAD); ctx.lineTo(W, CEIL_PAD); ctx.stroke();

    // ê·¸ë¦¬ë“œ ë²„ë¸”
    for(let r=0;r<grid.length;r++){
      for(let c=0;c<grid[r].length;c++){
        const cell = grid[r][c]; if(!cell) continue;
        const {x,y} = gridToXY(r,c);
        drawBubble(x,y, cell.color);
      }
    }

    // ì¡°ì¤€ì„ 
    const ang = aimAngle(mouse.x, mouse.y);
    const ax = W/2, ay = SHOOT_Y; const len = 60;
    ctx.strokeStyle = 'rgba(148,163,184,.5)'; ctx.setLineDash([6,6]); ctx.lineWidth = 2; ctx.beginPath();
    ctx.moveTo(ax,ay);
    ctx.lineTo(ax + Math.cos(ang)*len, ay + Math.sin(ang)*len);
    ctx.stroke(); ctx.setLineDash([]);

    // ë°œì‚¬ê¸°(ìºë…¼)
    drawCannon(ax,ay,ang);

    // í˜„ì¬ íƒ„í™˜ + ë‹¤ìŒ ìƒ‰ ë¯¸ë¦¬ë³´ê¸°
    if(current){ drawBubble(current.x,current.y,current.color, true); }
    // next
    drawBubble(36, H-36, nextColor);
    ctx.font = '700 12px system-ui'; ctx.fillStyle = '#93c5fd'; ctx.fillText('ë‹¤ìŒ', 16, H-56);
  }

  function drawBubble(x,y,color,glow=false){
    // í…Œë‘ë¦¬+í•˜ì´ë¼ì´íŠ¸ë¡œ ë³¼ë¥¨ê°
    ctx.save();
    if(glow){ ctx.shadowColor = color; ctx.shadowBlur = 12; }
    const radgrad = ctx.createRadialGradient(x-R/2,y-R/2, R*0.2, x,y,R);
    radgrad.addColorStop(0, '#ffffffcc');
    radgrad.addColorStop(.2, color);
    radgrad.addColorStop(1, '#00000080');
    ctx.fillStyle = radgrad;
    ctx.beginPath(); ctx.arc(x,y,R,0,Math.PI*2); ctx.fill();
    ctx.lineWidth = 2; ctx.strokeStyle = '#ffffff33'; ctx.stroke();
    ctx.restore();
  }

  function drawCannon(x,y,ang){
    ctx.save(); ctx.translate(x,y); ctx.rotate(ang);
    ctx.fillStyle = '#0f172a'; ctx.strokeStyle = '#334155'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.roundRect(-14,-10, 38,20, 8); ctx.fill(); ctx.stroke();
    ctx.restore();
    // ë°”ë‹¥ í¬ë””ì›€
    ctx.fillStyle = '#0f172a'; ctx.strokeStyle = '#334155'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.roundRect(x-40, y+8, 80, 20, 10); ctx.fill(); ctx.stroke();
  }

  // í´ë¦¬í•„(ë¼ìš´ë“œ ë ‰íŠ¸)
  if(!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+rr,y);
      this.arcTo(x+w,y,x+w,y+h,rr);
      this.arcTo(x+w,y+h,x,y+h,rr);
      this.arcTo(x,y+h,x,y,rr);
      this.arcTo(x,y,x+w,y,rr);
      this.closePath();
      return this;
    }
  }

  // ë£¨í”„
  function loop(){ step(); draw(); requestAnimationFrame(loop); }

  // ì‹œì‘
  function init(){ newGrid(START_ROWS); spawnProjectile(); updateUI(); loop(); }
  function hardReset(){ grid=[]; score=0; shots=0; pendingRows=5; gameOver=false; current=null; nextColor=COLORS[Math.floor(Math.random()*COLORS.length)]; newGrid(START_ROWS); }
  function softReset(){ score=0; shots=0; pendingRows=5; gameOver=false; current=null; nextColor=COLORS[Math.floor(Math.random()*COLORS.length)]; }

  function fullReset(){ hardReset(); toast.style.display='none'; updateUI(); }
  function resetGame(){ fullReset(); }

  init();
})();
</script>
</body>
</html>
