<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>버블버블 - Bubble Shooter</title>
  <style>
    :root {
      --bg:#0b1020; --panel:#111827; --text:#e5e7eb; --accent:#60a5fa; --good:#34d399; --bad:#f43f5e;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,sans-serif;
      background: radial-gradient(1200px 800px at 70% -20%, #1f2937, #0b1024 60%, #050816 100%);
      color: var(--text); display:grid; place-items:center; overflow: hidden;
    }
    .wrap { width:min(520px, 94vw); }
    .hud { display:grid; grid-template-columns:1fr auto; gap:.5rem; align-items:center;
      background:rgba(17,24,39,.6); backdrop-filter: blur(6px); padding:.75rem 1rem; border-radius: 1rem; box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    .hud h1 { margin:0; font-size:1.1rem; letter-spacing:.3px; font-weight:700; }
    .hud .right { display:flex; gap:.5rem; align-items:center; }
    .pill { padding:.35rem .6rem; border-radius: 999px; font-weight:700; font-size:.85rem; background:#0b1226; border:1px solid #1f2b4f; }
    .btn { cursor:pointer; user-select:none; padding:.45rem .8rem; border-radius: 999px; border:1px solid #2a375f; background: linear-gradient(180deg,#14204a,#0c1430); font-weight:700; }
    .btn:hover { filter: brightness(1.1); }
    .canvas-wrap { position: relative; margin-top:.75rem; border-radius: 1rem; overflow: hidden; box-shadow: 0 20px 40px rgba(0,0,0,.45); border:1px solid #1b2350; }
    canvas { display:block; width:100%; height:auto; background: linear-gradient(180deg,#0a0f22,#0c1a39 40%, #0b1020); }
    .help { opacity:.9; font-size:.9rem; text-align:center; margin-top:.5rem; }
    .toast { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
      background:rgba(15,23,42,.85); padding:1rem 1.25rem; border-radius:1rem; border:1px solid #334155; text-align:center;
      box-shadow: 0 10px 30px rgba(0,0,0,.45); display:none; }
    .toast h2 { margin:.1rem 0 .4rem; font-size:1.25rem; }
    .toast .row { display:flex; gap:.5rem; justify-content:center; margin-top:.25rem; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <h1>버블버블 · Bubble Shooter</h1>
      <div class="right">
        <span class="pill" id="score">점수 0</span>
        <span class="pill" id="rows">남은줄 0</span>
        <button class="btn" id="restart">다시 시작</button>
      </div>
    </div>

    <div class="canvas-wrap">
      <canvas id="game" width="480" height="720" aria-label="버블버블 게임 캔버스"></canvas>
      <div class="toast" id="toast">
        <h2 id="toast-title">게임 오버</h2>
        <div id="toast-msg">점수를 확인하고 다시 도전하세요!</div>
        <div class="row"><button class="btn" id="toast-restart">다시 시작</button></div>
      </div>
    </div>
    <div class="help">마우스(또는 손가락)로 조준하고 클릭/탭하여 발사! · 같은 색 3개 이상 연결하면 터집니다 💥</div>
  </div>

<script>
// === 버블버블: 순수 JS + Canvas (1파일 완성) ===============================
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const rowsEl = document.getElementById('rows');
  const restartBtn = document.getElementById('restart');
  const toast = document.getElementById('toast');
  const toastTitle = document.getElementById('toast-title');
  const toastMsg = document.getElementById('toast-msg');
  const toastRestart = document.getElementById('toast-restart');

  // 캔버스 크기 고정(비율 유지) + CSS로 반응형. 내부 좌표는 고정.
  const W = canvas.width; const H = canvas.height;

  // 격자 설정(벌집형 가까운 스태거드)
  const R = 16;                 // 버블 반지름
  const COLS = 12;              // 기본 열 수
  const ROW_H = Math.floor(R * 1.75); // 줄 간격 (대략 √3 * R)
  const START_ROWS = 6;         // 시작 줄 수
  const CEIL_PAD = 50;          // 천장 여유
  const SHOOT_Y = H - 60;       // 발사 위치 Y
  const MAX_ROWS = Math.floor((H - CEIL_PAD - 120) / ROW_H);

  const COLORS = ['#60a5fa','#f472b6','#fbbf24','#34d399','#a78bfa','#f97316','#22d3ee'];

  // 상태
  let grid = [];      // 2D 배열(행 -> 열)
  let score = 0;
  let shots = 0;
  let pendingRows = 5; // 일정 발사마다 줄 내려옴(카운트다운)
  let gameOver = false;

  // 발사체
  let current = null; // {x,y,vx,vy,color}
  let nextColor = COLORS[Math.floor(Math.random()*COLORS.length)];

  // 유틸
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  function newGrid(rows=START_ROWS){
    grid = [];
    for(let r=0;r<rows;r++){
      const odd = r % 2 === 1;
      const cols = odd ? COLS-1 : COLS;
      const row = new Array(cols).fill(null);
      // 임의로 색 채우기(연결 가능성 높이기)
      for(let c=0;c<cols;c++){
        row[c] = { color: COLORS[Math.floor(Math.random()*COLORS.length)] };
      }
      grid.push(row);
    }
  }

  function gridToXY(r,c){
    const odd = r % 2 === 1;
    const x0 = odd ? R*2 : R;
    const x = x0 + c * (R*2);
    const y = CEIL_PAD + r * ROW_H;
    return {x,y};
  }

  function xyToGrid(x,y){
    // 대략적인 반전 매핑: 후보 격자 4~6개 중 가장 가까운 위치로 스냅
    const rApprox = Math.round((y - CEIL_PAD)/ROW_H);
    const candidates = [];
    for(let dr=-1;dr<=1;dr++){
      const r = rApprox + dr;
      if(r<0) continue;
      const odd = r%2===1;
      const cols = odd? COLS-1: COLS;
      // col 근사: (x - x0) / (2R)
      const x0 = odd? R*2 : R;
      const cApprox = Math.round((x - x0)/(R*2));
      for(let dc=-1;dc<=1;dc++){
        const c = cApprox + dc;
        if(c<0||c>=cols) continue;
        const p = gridToXY(r,c);
        const d2 = (p.x - x)**2 + (p.y - y)**2;
        candidates.push({r,c,d2});
      }
    }
    if(candidates.length===0) return null;
    candidates.sort((a,b)=>a.d2-b.d2);
    return {r:candidates[0].r, c:candidates[0].c};
  }

  function neighbors(r,c){
    const odd = r%2===1;
    // 스태거드 6방향 근사
    const n = odd
      ? [[r-1,c],[r-1,c+1],[r,c-1],[r,c+1],[r+1,c],[r+1,c+1]]
      : [[r-1,c-1],[r-1,c],[r,c-1],[r,c+1],[r+1,c-1],[r+1,c]];
    return n.filter(([rr,cc])=> rr>=0 && rr<grid.length && cc>=0 && cc<grid[rr].length);
  }

  function floodSame(r,c,color,visited){
    const key = r+","+c;
    if(visited.has(key)) return;
    visited.add(key);
    for(const [rr,cc] of neighbors(r,c)){
      const cell = grid[rr]?.[cc];
      if(cell && cell.color===color) floodSame(rr,cc,color,visited);
    }
  }

  function removeFloating(){
    // 천장(0행)과 연결되지 않은 버블 제거
    const seen = new Set();
    for(let c=0;c<grid[0]?.length;c++){
      if(grid[0][c]) floodAttach(0,c,seen);
    }
    let removed = 0;
    for(let r=0;r<grid.length;r++){
      for(let c=0;c<grid[r].length;c++){
        const key = r+","+c;
        if(grid[r][c] && !seen.has(key)) { grid[r][c]=null; removed++; }
      }
    }
    return removed;
  }
  function floodAttach(r,c,seen){
    const key = r+","+c; if(seen.has(key)) return; seen.add(key);
    for(const [rr,cc] of neighbors(r,c)){
      const cell = grid[rr]?.[cc];
      if(cell) floodAttach(rr,cc,seen);
    }
  }

  function compressGrid(){
    // 맨 아래 비어있는 행 제거, 위로만 존재
    for(let r=grid.length-1;r>=0;r--){
      if(grid[r].every(v=>v==null)) grid.splice(r,1);
      else break;
    }
  }

  function spawnProjectile(){
    const color = nextColor;
    nextColor = COLORS[Math.floor(Math.random()*COLORS.length)];
    current = { x: W/2, y: SHOOT_Y, vx:0, vy:0, color };
  }

  function beginShot(angle){
    const speed = 7.2;
    current.vx = Math.cos(angle)*speed;
    current.vy = Math.sin(angle)*speed;
  }

  function tryAttach(){
    const snap = xyToGrid(current.x, current.y);
    if(!snap) return false;
    const {r,c} = snap;
    // 그리드 확장 필요 시
    while(r >= grid.length){
      const odd = grid.length % 2 === 1;
      const cols = odd? COLS-1: COLS;
      grid.push(new Array(cols).fill(null));
    }
    if(grid[r][c]) return false; // 이미 찬 자리면 실패(조금 더 진행)
    grid[r][c] = { color: current.color };

    // 그룹 검사(3개 이상)
    const visited = new Set();
    floodSame(r,c,current.color,visited);
    let removed = 0;
    if(visited.size >= 3){
      for(const k of visited){
        const [rr,cc] = k.split(',').map(Number);
        grid[rr][cc] = null; removed++;
      }
      score += removed * 10;
    }
    // 공중부양 제거
    const floating = removeFloating();
    if(floating>0) score += floating * 15;

    compressGrid();
    updateUI();

    // 게임 클리어 체크
    if(grid.length===0){
      endGame(true);
    }
    return true;
  }

  function lowerRows(n=1){
    // 아래로 한 줄 추가: 천장에 새 줄 삽입 효과
    for(let i=0;i<n;i++){
      const newTopOdd = 0 % 2 === 1; // 첫줄은 항상 짝수행(odd=false)
      const cols = newTopOdd ? COLS-1 : COLS;
      const row = new Array(cols).fill(null).map(()=>({color: COLORS[Math.floor(Math.random()*COLORS.length)]}));
      grid.unshift(row);
    }
    // 바닥 닿았는지 체크
    const lowestY = CEIL_PAD + (grid.length-1)*ROW_H + R;
    if(lowestY >= SHOOT_Y - R){
      endGame(false);
    }
  }

  function aimAngle(mx,my){
    const dx = mx - W/2; const dy = my - SHOOT_Y;
    let ang = Math.atan2(dy,dx);
    // 위쪽만 허용(발사각 제한)
    const minA = (-Math.PI + 0.2), maxA = (-0.2);
    ang = clamp(ang, minA, maxA);
    return ang;
  }

  // 입력 처리
  let mouse = {x:W/2, y:SHOOT_Y-100};
  function onPoint(x,y){ mouse.x=x; mouse.y=y; }
  canvas.addEventListener('mousemove', e=>{
    const rect = canvas.getBoundingClientRect();
    const scale = rect.width / W;
    onPoint((e.clientX-rect.left)/scale, (e.clientY-rect.top)/scale);
  });
  canvas.addEventListener('touchmove', e=>{
    const t = e.touches[0]; if(!t) return; const rect = canvas.getBoundingClientRect();
    const scale = rect.width / W;
    onPoint((t.clientX-rect.left)/scale, (t.clientY-rect.top)/scale);
  }, {passive:true});

  function shoot(){
    if(gameOver) return;
    if(!current) spawnProjectile();
    if(current.vx!==0||current.vy!==0) return; // 이미 발사중
    const ang = aimAngle(mouse.x, mouse.y);
    beginShot(ang);
    shots++;
    pendingRows--;
    if(pendingRows<=0){
      pendingRows = 5; // 5발 마다 한 줄 내려오기
      lowerRows(1);
      updateUI();
    }
  }
  canvas.addEventListener('click', shoot);
  canvas.addEventListener('touchstart', e=>{ shoot(); }, {passive:true});

  restartBtn.addEventListener('click', resetGame);
  toastRestart.addEventListener('click', resetGame);

  function updateUI(){
    scoreEl.textContent = `점수 ${score}`;
    rowsEl.textContent = `남은줄 ${pendingRows}`;
  }

  function endGame(clear){
    gameOver = true;
    toast.style.display = 'block';
    toastTitle.textContent = clear? '클리어! 🎉' : '게임 오버 💀';
    toastMsg.textContent = `최종 점수: ${score} · 발사수: ${shots}`;
  }

  function resetGame(){
    toast.style.display = 'none';
    score = 0; shots = 0; pendingRows = 5; gameOver = false;
    newGrid(START_ROWS);
    current = null; nextColor = COLORS[Math.floor(Math.random()*COLORS.length)];
    updateUI();
  }

  function step(){
    // 물리 업데이트
    if(current){
      if(current.vx!==0 || current.vy!==0){
        current.x += current.vx; current.y += current.vy;
        // 벽 반사
        if(current.x <= R){ current.x = R; current.vx *= -1; }
        if(current.x >= W - R){ current.x = W - R; current.vx *= -1; }
        // 천장 충돌
        if(current.y <= CEIL_PAD + R){ current.y = CEIL_PAD + R; if(tryAttach()) current = null; }
        else {
          // 다른 버블과 충돌 체크(원-원)
          outer: for(let r=0;r<grid.length;r++){
            for(let c=0;c<grid[r].length;c++){
              const cell = grid[r][c]; if(!cell) continue;
              const p = gridToXY(r,c);
              const dx = p.x - current.x; const dy = p.y - current.y;
              const dist = Math.hypot(dx,dy);
              if(dist <= R*2 - 0.5){ // 약간 겹치면 스냅
                // 충돌 지점에서 살짝 뒤로 이동(겹침 줄이기)
                const nx = dx/dist, ny = dy/dist;
                current.x = p.x - nx*(R*2);
                current.y = p.y - ny*(R*2);
                if(tryAttach()) current = null;
                break outer;
              }
            }
          }
          // 바닥에 닿으면 실패
          if(current && current.y >= SHOOT_Y - R){ endGame(false); current=null; }
        }
      }
    }
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    // 배경(가이드)
    const grd = ctx.createLinearGradient(0,0,0,H);
    grd.addColorStop(0,'#0a0f22'); grd.addColorStop(.5,'#0c1a39'); grd.addColorStop(1,'#0b1020');
    ctx.fillStyle = grd; ctx.fillRect(0,0,W,H);

    // 천장 라인
    ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 2; ctx.beginPath();
    ctx.moveTo(0, CEIL_PAD); ctx.lineTo(W, CEIL_PAD); ctx.stroke();

    // 그리드 버블
    for(let r=0;r<grid.length;r++){
      for(let c=0;c<grid[r].length;c++){
        const cell = grid[r][c]; if(!cell) continue;
        const {x,y} = gridToXY(r,c);
        drawBubble(x,y, cell.color);
      }
    }

    // 조준선
    const ang = aimAngle(mouse.x, mouse.y);
    const ax = W/2, ay = SHOOT_Y; const len = 60;
    ctx.strokeStyle = 'rgba(148,163,184,.5)'; ctx.setLineDash([6,6]); ctx.lineWidth = 2; ctx.beginPath();
    ctx.moveTo(ax,ay);
    ctx.lineTo(ax + Math.cos(ang)*len, ay + Math.sin(ang)*len);
    ctx.stroke(); ctx.setLineDash([]);

    // 발사기(캐논)
    drawCannon(ax,ay,ang);

    // 현재 탄환 + 다음 색 미리보기
    if(current){ drawBubble(current.x,current.y,current.color, true); }
    // next
    drawBubble(36, H-36, nextColor);
    ctx.font = '700 12px system-ui'; ctx.fillStyle = '#93c5fd'; ctx.fillText('다음', 16, H-56);
  }

  function drawBubble(x,y,color,glow=false){
    // 테두리+하이라이트로 볼륨감
    ctx.save();
    if(glow){ ctx.shadowColor = color; ctx.shadowBlur = 12; }
    const radgrad = ctx.createRadialGradient(x-R/2,y-R/2, R*0.2, x,y,R);
    radgrad.addColorStop(0, '#ffffffcc');
    radgrad.addColorStop(.2, color);
    radgrad.addColorStop(1, '#00000080');
    ctx.fillStyle = radgrad;
    ctx.beginPath(); ctx.arc(x,y,R,0,Math.PI*2); ctx.fill();
    ctx.lineWidth = 2; ctx.strokeStyle = '#ffffff33'; ctx.stroke();
    ctx.restore();
  }

  function drawCannon(x,y,ang){
    ctx.save(); ctx.translate(x,y); ctx.rotate(ang);
    ctx.fillStyle = '#0f172a'; ctx.strokeStyle = '#334155'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.roundRect(-14,-10, 38,20, 8); ctx.fill(); ctx.stroke();
    ctx.restore();
    // 바닥 포디움
    ctx.fillStyle = '#0f172a'; ctx.strokeStyle = '#334155'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.roundRect(x-40, y+8, 80, 20, 10); ctx.fill(); ctx.stroke();
  }

  // 폴리필(라운드 렉트)
  if(!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+rr,y);
      this.arcTo(x+w,y,x+w,y+h,rr);
      this.arcTo(x+w,y+h,x,y+h,rr);
      this.arcTo(x,y+h,x,y,rr);
      this.arcTo(x,y,x+w,y,rr);
      this.closePath();
      return this;
    }
  }

  // 루프
  function loop(){ step(); draw(); requestAnimationFrame(loop); }

  // 시작
  function init(){ newGrid(START_ROWS); spawnProjectile(); updateUI(); loop(); }
  function hardReset(){ grid=[]; score=0; shots=0; pendingRows=5; gameOver=false; current=null; nextColor=COLORS[Math.floor(Math.random()*COLORS.length)]; newGrid(START_ROWS); }
  function softReset(){ score=0; shots=0; pendingRows=5; gameOver=false; current=null; nextColor=COLORS[Math.floor(Math.random()*COLORS.length)]; }

  function fullReset(){ hardReset(); toast.style.display='none'; updateUI(); }
  function resetGame(){ fullReset(); }

  init();
})();
</script>
</body>
</html>
