<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
<title>버블버블 슈터</title>
<style>
  :root{ --bg:#0c1a2a; --panel:#0f2236; --text:#dbe7ff; --muted:#9fb6da; --chip:#172c44; --chipText:#cfe0ff; --btn:#153450; --btnBd:#2c5c85; }
  *,*::before,*::after{ box-sizing:border-box; }
  html,body{ margin:0; height:100%; background:var(--bg); color:var(--text);
    font-family:ui-sans-serif,system-ui,Apple SD Gothic Neo,Segoe UI,Roboto,Helvetica,Arial }
  .wrap{ max-width:920px; margin:0 auto; padding:16px 16px 28px }
  header{ display:flex; justify-content:space-between; align-items:flex-start; gap:12px; flex-wrap:wrap }
  h1{ font-size:30px; margin:6px 0 8px 0 }
  .desc{ margin:0 0 10px 0; color:#cfe4ff; line-height:1.45; font-size:15px }
  .desc .strong{ font-weight:800; color:#fff }
  .chips{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
  .chip{ background:var(--chip); border:1px solid #254760; color:var(--chipText); padding:8px 12px; border-radius:12px; font-weight:800 }
  .btn{ background:var(--btn); border:1px solid var(--btnBd); color:#e8f1ff; padding:8px 14px; border-radius:12px; font-weight:800; cursor:pointer }
  .btn:active{ transform:translateY(1px) }
  .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap }
  .nextWrap{ display:flex; align-items:center; gap:8px }
  .nextBubble{ width:22px; height:22px; border-radius:50%; border:2px solid rgba(255,255,255,.55); box-shadow:0 2px 6px rgba(0,0,0,.35) }
  .infoBar{ display:flex; align-items:center; gap:8px; padding:10px 12px; margin:8px 0 10px 0; background:#123253; border:1px solid #2b5e8a; border-radius:12px; color:#d6ecff; font-size:14px }
  .board{ background:var(--panel); border:1px solid #1b3752; border-radius:18px; box-shadow:0 10px 30px rgba(0,0,0,.35); padding:14px }
  canvas{ display:block; margin:0 auto; width:100%; height:auto; max-width:480px; touch-action:none }
  .hint{ color:var(--muted); font-size:13.5px; text-align:center; margin-top:10px }
  .overlay{ position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.55); z-index:50 }
  .card{ background:#0e2034; border:1px solid #254760; border-radius:16px; padding:22px; max-width:360px }
  .card h2{ margin:0 0 8px 0 } .card p{ margin:6px 0 0 0; color:#cbd9f6 }
  .help ul{ padding-left:18px; margin:8px 0; color:#cbd9f6 }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>버블버블 슈터</h1>
        <p class="desc">
          상단의 버블 무리를 향해 공을 발사해 <span class="strong">같은 색 3개 이상</span>을 연결하면 터집니다.
          <br><span class="strong">상단의 버블 영역에서 원하는 지점(방향)을 탭/클릭</span>하면 그쪽으로 정확히 발사돼요.
          발사 <span class="strong">5번</span>마다 윗줄이 한 칸 내려오니 빠르게 연결을 노려보세요!
        </p>
        <div class="row">
          <div class="chips">
            <div class="chip">점수 <span id="score">0</span></div>
            <div class="chip">남은 줄 <span id="rows-left">5</span></div>
          </div>
          <div class="nextWrap">
            <span style="color:#a9c4ea;font-size:14px">다음</span>
            <div id="next-color" class="nextBubble"></div>
          </div>
        </div>
      </div>
      <div class="row">
        <button id="help" class="btn">도움말</button>
        <button id="restart" class="btn">다시 시작</button>
      </div>
    </header>

    <div class="infoBar">💡 상단의 버블 쪽, <b>쏘고 싶은 방향</b>을 탭/클릭하면 그쪽으로 발사됩니다.</div>

    <div class="board">
      <canvas id="game" width="480" height="680" aria-label="Bubble Shooter"></canvas>
    </div>
    <p class="hint">조준선이 보일 때 원하는 방향을 터치해 발사하세요. 같은 색 3개 이상이면 터집니다.</p>
  </div>

  <!-- Game Over -->
  <div class="overlay" id="gameover">
    <div class="card">
      <h2>게임 오버 💀</h2>
      <p>최종 점수: <b id="final-score">0</b> · 발사수: <b id="shots-used">0</b></p>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end">
        <button id="again" class="btn">다시 시작</button>
        <button id="go-help" class="btn">도움말</button>
      </div>
    </div>
  </div>

  <!-- Help -->
  <div class="overlay" id="helpbox">
    <div class="card help">
      <h2>🎮 버블버블 슈터 사용 가이드</h2>
      <ul>
        <li><b>목표:</b> 상단의 버블을 <b>같은 색 3개 이상</b>으로 이어 터뜨리기</li>
        <li><b>발사:</b> 화면을 탭(클릭)하면 <b>그 방향</b>으로 공이 날아갑니다. <i>상단 버블 영역을 찍으면 더 정확해요.</i></li>
        <li><b>점수:</b> 터뜨린 개수 × 10점 · 떨어진(부유) 버블은 절반 점수</li>
        <li><b>줄 내려옴:</b> <b>발사 5번</b>마다 맨 윗줄이 1칸 아래로 내려와요</li>
        <li><b>게임 종료:</b> 버블이 <b>바닥선</b>에 닿으면 종료 · “다시 시작”으로 재도전</li>
        <li><b>팁:</b> 가로모드가 시야가 넓어요 · 브라우저 메뉴의 “홈 화면에 추가”로 앱처럼 사용</li>
      </ul>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end">
        <button id="help-close" class="btn">닫기</button>
        <button id="help-restart" class="btn">다시 시작</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // ==== Refs ====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const rowsLeftEl = document.getElementById('rows-left');
  const nextColorEl = document.getElementById('next-color');
  const overlay = document.getElementById('gameover');
  const finalScoreEl = document.getElementById('final-score');
  const shotsUsedEl = document.getElementById('shots-used');
  const againBtn = document.getElementById('again');
  const goHelpBtn = document.getElementById('go-help');
  const helpBtn = document.getElementById('help');
  const helpBox = document.getElementById('helpbox');
  const helpClose = document.getElementById('help-close');
  const helpRestart = document.getElementById('help-restart');
  const restartBtn = document.getElementById('restart');

  // ==== Config ====
  const COLORS = ['#4fc3f7','#ab47bc','#ff7043','#ffd54f','#66bb6a','#29b6f6','#ec407a','#9ccc65'];
  const MAX_CANVAS_W = 480, SAFE_BOTTOM = 60, INIT_ROWS = 5;
  const SHOTS_PER_NEWROW = 5, SCORE_PER_BUBBLE = 10, TOP_OFFSET = 18;

  // ==== Sizes (CSS px 기준) ====
  let CSS_W=360, CSS_H=486, DPR=1;

  // Hex layout
  let R=16, H_SP=32, V_SP=28, GRID_COLS=12, GRID_ROWS=22;

  // ==== State ====
  let grid=[], shooter={x:0,y:0,angle:-Math.PI/2}, active=null, nextColor=rand();
  let score=0, shots=0, shotsLeft=SHOTS_PER_NEWROW, gameOver=false;

  // ==== Utils ====
  function rand(){ return COLORS[(Math.random()*COLORS.length)|0]; }
  function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }
  function dist2(x1,y1,x2,y2){ const dx=x1-x2, dy=y1-y2; return dx*dx+dy*dy; }

  // ==== Resize: 부모(.board) 너비 기준 ====
  function resize(){
    const board = document.querySelector('.board');
    const pad = 28; // .board padding (좌우 14px씩) 보정
    const avail = Math.max(200, board.clientWidth - pad);
    CSS_W = Math.min(avail, MAX_CANVAS_W);
    CSS_H = Math.round(CSS_W*1.35);
    DPR = window.devicePixelRatio || 1;

    canvas.style.width = CSS_W+'px';
    canvas.style.height = CSS_H+'px';
    canvas.width  = Math.round(CSS_W*DPR);
    canvas.height = Math.round(CSS_H*DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);

    R = Math.max(13, Math.min(18, Math.round(CSS_W/30)));
    H_SP = 2*R; V_SP = Math.sqrt(3)*R*0.95;

    GRID_COLS = Math.max(10, Math.floor((CSS_W - R)/H_SP));
    GRID_ROWS = Math.floor((CSS_H - TOP_OFFSET - SAFE_BOTTOM)/V_SP) - 1;

    shooter = { x: CSS_W/2, y: CSS_H - SAFE_BOTTOM/2, angle: -Math.PI/2 };
  }

  // ==== Grid ====
  function newGrid(){
    grid = Array.from({length: GRID_ROWS}, ()=> Array(GRID_COLS).fill(null));
    for(let r=0;r<INIT_ROWS;r++){ for(let c=0;c<colN(r);c++) grid[r][c]=rand(); }
  }
  function colN(r){ return GRID_COLS - (r%2?1:0); }
  function cellToXY(r,c){ return { x:R + (r%2?R:0) + c*H_SP + R, y:TOP_OFFSET + r*V_SP + R }; }
  function xyToCell(x,y){
    let r=Math.round((y - TOP_OFFSET - R)/V_SP); r=clamp(r,0,GRID_ROWS-1);
    const off=(r%2?R:0)+R; let c=Math.round((x-off)/H_SP); c=clamp(c,0,colN(r)-1);
    return {r,c};
  }
  function neigh(r,c){
    const odd=r%2===1;
    const list=[[r,c-1],[r,c+1],[r-1,c-(odd?0:1)],[r-1,c+(odd?1:0)],[r+1,c-(odd?0:1)],[r+1,c+(odd?1:0)]];
    return list.filter(([rr,cc])=>rr>=0&&rr<GRID_ROWS&&cc>=0&&cc<colN(rr));
  }
  function isInside(r,c){ return r>=0&&r<GRID_ROWS&&c>=0&&c<colN(r); }
  function isEmpty(r,c){ return isInside(r,c) && !grid[r][c]; }

  // ==== Flow ====
  function endGame(){ gameOver=true; finalScoreEl.textContent=String(score); shotsUsedEl.textContent=String(shots); overlay.style.display='grid'; }
  function addTopRow(){
    grid.pop(); grid.unshift(Array(GRID_COLS).fill(null));
    for(let c=0;c<colN(0);c++) grid[0][c]=rand();
    // bottom check
    for(let r=GRID_ROWS-1;r>=0;r--) for(let c=0;c<colN(r);c++){
      if(grid[r][c]){ const {y}=cellToXY(r,c); if(y+R>=shooter.y-R){ endGame(); return; } }
    }
  }
  function reset(){
    score=0; shots=0; shotsLeft=SHOTS_PER_NEWROW; gameOver=false;
    scoreEl.textContent='0'; rowsLeftEl.textContent=String(shotsLeft);
    overlay.style.display='none'; helpBox.style.display='none';
    resize(); newGrid(); active=null; nextColor=rand(); nextColorEl.style.background=nextColor;
  }

  // ==== Input (Pointer Events) ====
  function aim(mx,my){
    const dx=mx-shooter.x, dy=my-shooter.y; let a=Math.atan2(dy,dx);
    if(a>-0.1)a=-0.1; if(a<-Math.PI+0.1)a=-Math.PI+0.1; shooter.angle=a;
  }
  function shoot(mx,my){
    if(gameOver||active) return;
    aim(mx,my);
    const speed=Math.max(320,Math.min(560,R*28));
    active={x:shooter.x,y:shooter.y,vx:Math.cos(shooter.angle)*speed,vy:Math.sin(shooter.angle)*speed,color:nextColor};
    nextColor=rand(); nextColorEl.style.background=nextColor;
    shots++; shotsLeft--; if(shotsLeft<=0){ addTopRow(); shotsLeft=SHOTS_PER_NEWROW; }
    rowsLeftEl.textContent=String(shotsLeft);
  }
  function rel(e){ const r=canvas.getBoundingClientRect(); return { x:(e.clientX??0)-r.left, y:(e.clientY??0)-r.top }; }
  canvas.addEventListener('pointermove', e=>{ if(e.pointerType==='touch'||e.pointerType==='pen'||e.buttons===1){ const p=rel(e); aim(p.x,p.y);} });
  canvas.addEventListener('pointerdown', e=>{ e.preventDefault(); const p=rel(e); shoot(p.x,p.y); }, {passive:false});

  // ==== Physics ====
  function update(dt){
    if(!active) return;
    active.x += active.vx*dt; active.y += active.vy*dt;
    if(active.x<=R+2){ active.x=R+2; active.vx*=-1; }
    if(active.x>=CSS_W-R-2){ active.x=CSS_W-R-2; active.vx*=-1; }
    if(active.y<=TOP_OFFSET+R){ snap(); return; }
    outer: for(let r=0;r<GRID_ROWS;r++) for(let c=0;c<colN(r);c++){
      const col=grid[r][c]; if(!col) continue; const pos=cellToXY(r,c);
      if(dist2(active.x,active.y,pos.x,pos.y)<=(2*R-1)**2){ snap(); break outer; }
    }
    if(active && active.y>=shooter.y - R){ snap(true); } // bottom guard
  }
  function placeNear(r,c){
    if(isEmpty(r,c)){ grid[r][c]=active.color; return true; }
    const vis=new Set(), q=[[r,c]];
    while(q.length){
      const [rr,cc]=q.shift(), key=rr+','+cc; if(vis.has(key)) continue; vis.add(key);
      if(isInside(rr,cc)){
        if(isEmpty(rr,cc)){ grid[rr][cc]=active.color; return true; }
        neigh(rr,cc).forEach(n=>q.push(n));
      }
    }
    return false;
  }
  function snap(forceAbove=false){
    let {r,c}=xyToCell(active.x,active.y);
    if(forceAbove) r=clamp(r-1,0,GRID_ROWS-1);
    if(!placeNear(r,c) && !placeNear(clamp(r-1,0,GRID_ROWS-1),c)){
      for(let rr=0; rr<GRID_ROWS; rr++){ const cc=clamp(Math.round(c),0,colN(rr)-1); if(placeNear(rr,cc)) break; }
    }
    active=null; resolve();
  }
  function resolve(){
    const toRemove=new Set();
    for(let r=0;r<GRID_ROWS;r++) for(let c=0;c<colN(r);c++){
      const color=grid[r][c]; if(!color) continue;
      const cluster=flood(r,c,color); if(cluster.length>=3) cluster.forEach(k=>toRemove.add(k));
    }
    if(toRemove.size){
      toRemove.forEach(k=>{ const [rr,cc]=k.split(',').map(Number); grid[rr][cc]=null; });
      score += toRemove.size * SCORE_PER_BUBBLE; scoreEl.textContent=String(score);
    }
    drop();
    for(let r=0;r<GRID_ROWS;r++) for(let c=0;c<colN(r);c++){
      if(!grid[r][c]) continue; const {y}=cellToXY(r,c);
      if(y+R>=shooter.y-R){ endGame(); return; }
    }
  }
  function flood(sr,sc,color){
    const vis=new Set(), out=[], q=[[sr,sc]];
    while(q.length){ const [r,c]=q.pop(), key=r+','+c; if(vis.has(key)) continue; vis.add(key);
      if(!isInside(r,c) || grid[r][c]!==color) continue; out.push(key); neigh(r,c).forEach(n=>q.push(n)); }
    return out;
  }
  function drop(){
    const vis=new Set(), q=[]; for(let c=0;c<colN(0);c++) if(grid[0][c]) q.push([0,c]);
    while(q.length){ const [r,c]=q.pop(), key=r+','+c; if(vis.has(key)) continue; vis.add(key);
      neigh(r,c).forEach(([rr,cc])=>{ if(grid[rr][cc]) q.push([rr,cc]); });
    }
    let d=0; for(let r=0;r<GRID_ROWS;r++) for(let c=0;c<colN(r);c++) if(grid[r][c]&&!vis.has(r+','+c)){ grid[r][c]=null; d++; }
    if(d){ score += d*5; scoreEl.textContent=String(score); }
  }

  // ==== Render ====
  function bubble(x,y,color){
    ctx.beginPath(); ctx.arc(x,y,R,0,Math.PI*2);
    const g=ctx.createRadialGradient(x-R/3,y-R/3,R*0.2,x,y,R);
    g.addColorStop(0, lighten(color,.25)); g.addColorStop(1,color);
    ctx.fillStyle=g; ctx.fill();
    ctx.beginPath(); ctx.arc(x-R/3,y-R/3,R*0.35,0,Math.PI*2);
    ctx.fillStyle='rgba(255,255,255,.25)'; ctx.fill();
    ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,.55)'; ctx.stroke();
  }
  function lighten(hex,amt){
    const c=parseInt(hex.slice(1),16); let r=(c>>16)&255,g=(c>>8)&255,b=c&255;
    r=Math.min(255,Math.round(r+(255-r)*amt));
    g=Math.min(255,Math.round(g+(255-g)*amt));
    b=Math.min(255,Math.round(b+(255-b)*amt));
    return `rgb(${r},${g},${b})`;
  }
  function draw(){
    ctx.clearRect(0,0,CSS_W,CSS_H);
    for(let r=0;r<GRID_ROWS;r++) for(let c=0;c<colN(r);c++){
      const col=grid[r][c]; if(!col) continue; const {x,y}=cellToXY(r,c); bubble(x,y,col);
    }
    if(active){ bubble(active.x,active.y,active.color); } else { bubble(shooter.x, shooter.y, nextColor); }
    ctx.globalAlpha=.5; ctx.beginPath();
    ctx.moveTo(shooter.x,shooter.y);
    ctx.lineTo(shooter.x+Math.cos(shooter.angle)*80, shooter.y+Math.sin(shooter.angle)*80);
    ctx.lineWidth=4; ctx.strokeStyle='#9cc9ff'; ctx.stroke(); ctx.globalAlpha=1;
    ctx.beginPath(); ctx.moveTo(8, shooter.y+R); ctx.lineTo(CSS_W-8, shooter.y+R);
    ctx.lineWidth=2; ctx.strokeStyle='#214f7a'; ctx.stroke();
  }

  // ==== Loop & wiring ====
  let last=0;
  function tick(ts){ if(!last) last=ts; const dt=Math.max(0.008,Math.min(0.02,(ts-last)/1000)); last=ts;
    if(!gameOver){ update(dt); draw(); requestAnimationFrame(tick); } }
  restartBtn.addEventListener('click', reset);
  againBtn.addEventListener('click', reset);
  goHelpBtn.addEventListener('click', ()=>{ overlay.style.display='none'; helpBox.style.display='grid'; });
  helpBtn.addEventListener('click', ()=> helpBox.style.display='grid');
  helpClose.addEventListener('click', ()=> helpBox.style.display='none');
  helpRestart.addEventListener('click', ()=>{ helpBox.style.display='none'; reset(); });

  // 화면 변화(회전/주소창 크기변화 등)에도 안정
  ['resize','orientationchange','visibilitychange'].forEach(ev=>{
    window.addEventListener(ev, ()=>{ const wasActive=!!active; resize(); if(wasActive) active=null; });
  });

  // Start
  window.onload = () => { reset(); requestAnimationFrame(tick); };
})();
</script>
</body>
</html>
